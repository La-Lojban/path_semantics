fn main() {
    /*
    a := unwrap(test(2, 3))
    b := unwrap(test(3, 3))
    c := unwrap(test(2, 2))
    d := unwrap(test(3, 2))
    e := unwrap(test(0, 1))
    f := unwrap(test(1, 0))
    print_data(a)
    c := infer([a.equivs, b.equivs, c.equivs, d.equivs, e.equivs, f.equivs])
    */

    /*
    // Lists, including empty.
    a := unwrap(test([], [1]))
    b := unwrap(test([1], [2, 3]))
    c := unwrap(test([2, 4], [8, 1]))
    d := unwrap(test([8, 1], [2, 4]))
    print_data(a)
    c := infer([a.equivs, b.equivs, c.equivs, d.equivs])
    */

    /*
    // Non-empty lists.
    a := unwrap(test([1], [2, 3]))
    b := unwrap(test([2, 4], [8, 1, 3]))
    c := unwrap(test([2, 4, 5], [8, 1, 3]))
    d := unwrap(test([8, 1, 3], [2, 4, 5]))
    print_data(a)
    c := infer([a.equivs, b.equivs, c.equivs, d.equivs])
    */

    /*
    v := [0, 1]
    r := []
    for i, j, k {
        a := unwrap(test(v[i], v[j], v[k]))
        // print_data(a)
        push(mut r, a.equivs)
    }
    c := infer(r)
    */

    // `sin(x)` is approximately equal to `x` when near 0.
    input := [-0.2, -0.1, 0, 0.1, 0.2]
    a := {}
    eps := 0.002
    c := infer(sift i {
        a = unwrap(test(input[i], eps))
        a.equivs
    })

    if len(c) > 0 {
        println("========== Found equivalences!!! ==========\n")
        for i {println(link {str(c[i][0])" == "str(c[i][1])})}
        println("\n===========================================")
    } else {
        println("(No equivalences found)")
    }
}

fn test(x, eps) -> res[{}] {
    data := {
        x: x,
        sin: \(a) = sin(a),
        cos: \(a) = cos(a),
        approx_eq: \(eps) = \(a) = \(b) = abs((grab a) - b) < (grab '2 eps),
        t: true,
        eps: eps,
        one: 1,
        zero: 0,
        pi: 3.14159265358979323846264338327950288,
        tau: 3.14159265358979323846264338327950288 * 2,
        neg: \(a) = -a,
        pi_half: 3.14159265358979323846264338327950288 / 2,
    }
    filter := [
        ["sin"],
        ["approx_eq"],
        ["approx_eq(eps)"],
        ["approx_eq(eps)(sin(x))"],
        ["cos"],
        ["neg"],
    ]
    explore := [
        ["sin", "x"],
        ["approx_eq", "eps"],
        ["approx_eq(eps)", "sin(x)"],
        ["approx_eq(eps)(sin(x))", "x"],
        /*
        ["cos", "zero"],
        ["sin", "zero"],
        ["cos", "pi"],
        ["neg", "one"],
        ["sin", "pi_half"],
        ["sin", "tau"],
        ["cos", "tau"],
        */
    ]

    return wrap_fill(data: mut data, explore: explore, filter: filter)
}

/*
fn test(x, y) -> res[{}] {
    data := {
        x: x,
        y: y,
        len: \(a) = len(a),
        add: \(a) = \(b) = (grab a) + b,
        concat: \(a) = \(b) = {
            return = grab a
            for i {push(mut return, b[i])}
        },
        sum: \(a) = sum i {a[i]},
        sum2: \(a) = \(b) = (grab a) + b,
        min: \(a) = min i {a[i]},
        min2: \(a) = \(b) = min([grab a, b]),
        max: \(a) = max i {a[i]},
        max2: \(a) = \(b) = max([grab a, b]),
    }
    filter := [
        ["add"],
        ["add(len(x))"],
        ["concat"],
        ["concat(x)"],
        ["min2"],
        ["min2(min(x))"],
        ["max2"],
        ["max2(max(x))"],
        ["sum2"],
        ["sum2(sum(x))"],
    ]
    explore := [
        ["len", "x"],
        ["len", "y"],
        ["add", "len(x)"],
        ["add(len(x))", "len(y)"],
        ["concat", "x"],
        ["concat(x)", "y"],
        ["len", "concat(x)(y)"],
        ["sum", "x"],
        ["sum", "y"],
        ["sum", "concat(x)(y)"],
        ["min", "x"],
        ["min", "y"],
        ["min", "concat(x)(y)"],
        ["min2", "min(x)"],
        ["min2(min(x))", "min(y)"],
        ["max", "x"],
        ["max", "y"],
        ["max", "concat(x)(y)"],
        ["max2", "max(x)"],
        ["max2(max(x))", "max(y)"],
        ["sum2", "sum(x)"],
        ["sum2(sum(x))", "sum(y)"],
    ]

    return wrap_fill(data: mut data, explore: explore, filter: filter)
}
*/

/*
fn test(x, y, z) -> res[{}] {
    data := {
        le: \(a) = \(b) = (grab a) <= b,
        and: \(a) = \(b) = (grab a) && b,
        imp: \(a) = \(b) = if grab a {clone(b)} else {true},
        x: x,
        y: y,
        z: z,
        t: true,
    }
    filter := [
        ["imp"],
        ["and"],
        ["le"],
        ["le(x)"],
        ["le(y)"],
        ["and(le(x)(y))"],
        ["imp(and(le(x)(y))(le(y)(z)))"],
        ["le(y)(y)"],
        ["le(x)(x)"],
        ["and(le(x)(y))(t)"],
    ]
    explore := [
        ["le", "x"],
        ["le(x)", "y"],
        ["le(x)", "z"],
        ["le", "y"],
        ["le(y)", "z"],
        ["and", "le(x)(y)"],
        ["and(le(x)(y))", "le(y)(z)"],
        ["imp", "and(le(x)(y))(le(y)(z))"],
        ["imp(and(le(x)(y))(le(y)(z)))", "le(x)(z)"],
    ]

    return wrap_fill(data: mut data, explore: explore, filter: filter)
}
*/

/*
fn test(x, y) -> res[{}] {
    data := {
        gt: \(a) = \(b) = (grab a) > b,
        le: \(a) = \(b) = (grab a) <= b,
        not: \(a) = !a,
        x: x,
        y: y,
    }
    filter := [
        ["not"],
        ["gt"],
        ["le"],
        ["le(x)"],
        ["gt(x)"],
    ]
    explore := [
        ["le", "x"],
        ["le(x)", "y"],
        ["not", "le(x)(y)"],
        ["gt", "x"],
        ["gt(x)", "y"],
    ]

    return wrap_fill(data: mut data, explore: explore, filter: filter)
}
*/

/*
fn test(x, y) -> res[{}] {
    data := {
        add: \(a) = \(b) = (grab a) + b,
        mul: \(a) = \(b) = (grab a) * b,
        even: \(a) = (a % 2) == 0,
        and: \(a) = \(b) = (grab a) && b,
        or: \(a) = \(b) = (grab a) || b,
        is_zero: \(a) = a == 0,
        eq: \(a) = \(b) = (grab a) == b,
        xy: [x, y],
        fst: \(xy) = clone(xy[0]),
        snd: \(xy) = clone(xy[1]),
    }
    filter := [
        ["mul"],
        ["or"],
        ["add"],
        ["and"],
        ["eq"],
        ["eq(even(fst(xy)))"],
        ["add(fst(xy))"],
        ["mul(fst(xy))"],
        ["or(even(fst(xy)))"],
        ["and(is_zero(fst(xy)))"],
        ["or(is_zero(fst(xy)))"],
    ]
    explore := [
        ["fst", "xy"],
        ["snd", "xy"],
        ["even", "fst(xy)"],
        ["even", "snd(xy)"],
        ["is_zero", "fst(xy)"],
        ["is_zero", "snd(xy)"],
        ["eq", "even(fst(xy))"],
        ["eq(even(fst(xy)))", "even(snd(xy))"],
        ["add", "fst(xy)"],
        ["add(fst(xy))", "snd(xy)"],
        ["even", "add(fst(xy))(snd(xy))"],
        ["is_zero", "add(fst(xy))(snd(xy))"],
        ["mul", "fst(xy)"],
        ["mul(fst(xy))", "snd(xy)"],
        ["is_zero", "mul(fst(xy))(snd(xy))"],
        ["even", "mul(fst(xy))(snd(xy))"],
        ["or", "even(fst(xy))"],
        ["or(even(fst(xy)))", "even(snd(xy))"],
        ["and", "is_zero(fst(xy))"],
        ["and(is_zero(fst(xy)))", "is_zero(snd(xy))"],
        ["or", "is_zero(fst(xy))"],
        ["or(is_zero(fst(xy)))", "is_zero(snd(xy))"],
    ]

    return wrap_fill(data: mut data, explore: explore, filter: filter)
}
*/
