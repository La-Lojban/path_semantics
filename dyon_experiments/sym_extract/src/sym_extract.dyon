
/// Infers whether a path can be used for a function
/// in a symmetric way for both arguments and result.
sym(f: \([]) -> any, p: \([]) -> any, args: []) =
    all i {is_ok(try \p([args[i]]))} &&
    is_ok(try \p([\f(args)]))

// Find symmetric path candidates.
find_sym_candidates__functions_data(fs, data) = {
    fs_keys := keys(fs)
    n := len(fs_keys)
    sym_candidates := []
    for i, j {
        a := fs_keys[i]
        b := fs_keys[j]
        if !all h {sym(fs[a], fs[b], data[h])} {continue}
        push(mut sym_candidates, [a, b])
    }
    clone(sym_candidates)
}

// "id" is a very frequent path, so we ignore it.
filter_id(sym_candidates: 'return) = sift i {
    if (sym_candidates[i][0] == "id") ||
       (sym_candidates[i][1] == "id") {continue}
    sym_candidates[i]
}

/// Finds symmetric paths.
find_sym_paths__functions_candidates_data(fs, sym_candidates, data) = {
    fs_keys := keys(fs)
    sym_paths := []
    for i {
        a := sym_candidates[i][0]
        b := sym_candidates[i][1]
        fa := fs[a]
        fb := fs[b]
        for j {
            c := fs_keys[j]
            fc := fs[c]
            if all h {
                ls := try \fb([\fa(data[h])])
                rs := try \fc(sift k {\fb([data[h][k]])})
                if is_err(ls) || is_err(rs) {false}
                else {
                    cmp := try unwrap(ls) == unwrap(rs)
                    if is_err(cmp) {false}
                    else {unwrap(cmp)}
                }
            } {
                push(mut sym_paths, [a, b, c])
            }
        }
    }
    clone(sym_paths)
}

/// Filter away bad symmetric paths.
filter_bad__sympaths(sym_paths: 'return) = {
    filter := [
        ["add", "not", "and"],
        ["add", "not", "mul"],
        ["and", "not", "add"],
        ["and", "not", "mul"],
        ["exc", "even", "eq"],
        ["exc", "odd", "exc"],
        ["exc", "odd", "sub"],
        ["exc", "abs_odd", "neq"],
        ["exc", "neg", "sub"],
        ["exc", "neg", "exc"],
        ["max", "even", "mul"],
        ["mul", "not", "add"],
        ["mul", "abs_odd", "mul"],
        ["mul", "not", "or"],
        ["mul", "odd", "mul"],
        ["mul", "even", "add"],
        ["or", "not", "mul"],
        ["rexc", "even", "eq"],
        ["rexc", "odd", "rexc"],
        ["rexc", "neg", "rexc"],
        ["sub", "odd", "sub"],
        ["sub", "neg", "exc"],
        ["sign", "sqrt", "sign"],

        ["neg", "atan", "neg"],
        ["cos", "neg_odd", "and"],
        ["neg", "tan", "neg"],
        ["sqrt", "sign", "id"],
        ["exc", "abs_odd", "xor"],
        ["cos", "sign", "neg"],
        ["sqrt", "neg_odd", "and"],
        ["sin", "sign", "sign"],
        ["abs", "tan", "id"],
        ["atan", "sign", "id"],
        ["inv", "sign", "sign"],
        ["sqrt", "sign", "inv"],
        ["exc", "even", "nxor"],
        ["rexc", "even", "nxor"],
        ["neg", "sign", "sign"],
        ["sqrt", "abs_odd", "or"],
        ["mul", "odd", "xor"],
        ["exc", "neg_odd", "xor"],
        ["sqrt", "neg_odd", "exc"],
        ["abs", "atan", "id"],
        ["abs", "neg", "id"],
        ["sin", "neg_odd", "and"],
        ["sqrt", "sign", "xor"],
        ["rexc", "abs_odd", "neq"],
        ["mul", "sign", "div"],
        ["neg", "neg", "abs"],
        ["rexc", "abs_odd", "xor"],
        ["sin", "neg_odd", "id"],
        ["sqrt", "sign", "abs"],
        ["atan", "neg_odd", "id"],
        ["sign", "abs", "sign"],
        ["abs", "even", "id"],
        ["neg", "abs", "abs"],
        ["abs", "sin", "abs"],
        ["atan", "sign", "xor"],
        ["add", "even", "mul"],
        ["abs", "sign", "abs"],
        ["rexc", "odd", "id"],
        ["abs", "atan", "abs"],
        ["neg", "abs_odd", "id"],
        ["atan", "abs", "atan"],
        ["abs", "abs_odd", "id"],
        ["sqrt", "abs", "sqrt"],
        ["atan", "neg_odd", "and"],
        ["sqrt", "neg_odd", "id"],

        ["sub", "not", "nrexc"],
        ["nrexc", "not", "sub"],
    ]
    sift i {
        if any j {filter[j] == sym_paths[i]} {continue}
        if all j {sym_paths[i][j] == sym_paths[i][0]} {continue}
        sym_paths[i]
    }
}

/// Filter away good symmetric paths.
filter_good__sympaths(sym_paths: 'return) = {
    filter := [
        // Booleans.
        ["and", "not", "or"],
        ["or", "not", "and"],
        ["xor", "not", "nxor"],
        ["xor", "not", "eq"],
        ["eq", "not", "neq"],
        ["eq", "not", "xor"],
        ["exc", "not", "nrexc"],
        ["rexc", "not", "nexc"],

        ["nand", "not", "nor"],
        ["nor", "not", "nand"],
        ["nxor", "not", "neq"],
        ["nxor", "not", "xor"],
        ["neq", "not", "eq"],
        ["neq", "not", "nxor"],
        ["not", "not", "not"],
        ["nexc", "not", "rexc"],
        ["nrexc", "not", "exc"],

        // List.
        ["concat", "len", "add"],
        ["concat", "sum", "add"],

        // Numbers.
        ["mul", "inv", "mul"],
        ["mul", "abs", "mul"],
        ["mul", "sign", "mul"],
        ["div", "abs", "div"],
        ["tan", "neg", "tan"],
        ["abs", "inv", "abs"],
        ["neg", "sign", "neg"],
        ["neg", "inv", "neg"],
        ["neg", "abs", "id"],
        ["neg", "sin", "neg"],
        ["neg", "cos", "id"],
        ["abs", "abs", "id"],
        ["abs", "cos", "id"],
        ["inv", "neg", "inv"],
        ["inv", "abs", "inv"],
        ["sin", "neg", "sin"],
        ["sign", "neg", "sign"],
        ["cos", "sign", "sign"],
        ["sub", "neg", "sub"],
        ["atan", "neg", "atan"],
        ["atan", "sign", "inv"],
        ["add", "neg", "add"],

        // Integers.
        ["neg", "even", "id"],
        ["mul", "even", "or"],
        ["mul", "abs_odd", "and"],
        ["sub", "even", "nxor"],
        ["sub", "abs_odd", "xor"],
        ["sub", "even", "eq"],
        ["sub", "abs_odd", "neq"],
        ["add", "even", "nxor"],
        ["add", "even", "eq"],
        ["add", "abs_odd", "xor"],
        ["add", "abs_odd", "neq"],

        // Square positive integers.
        ["sqrt", "even", "id"],
        ["sqrt", "abs_odd", "id"],
        ["sqrt", "odd", "id"],
    ]
    sift i {
        if any j {filter[j] == sym_paths[i]} {continue}
        sym_paths[i]
    }
}

/// Extract symmetric paths using function knowledge and data.
extract_sym__functions_data(fs, data) = {
    sym_candidates := find_sym_candidates(functions: fs, data: data)
    sym_candidates := filter_id(sym_candidates)
    sym_paths := find_sym_paths(
        functions: fs,
        candidates: sym_candidates,
        data: data
    )
    clone(filter_bad(sympaths: sym_paths))
}
